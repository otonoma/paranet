"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[19],{6778:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(4848),r=i(8453);const s={id:"bindings",title:"Bindings",sidebar_position:8},a="Bindings",l={id:"paraflow/bindings",title:"Bindings",description:"Call Bindings",source:"@site/paranet/paraflow/bindings.md",sourceDirName:"paraflow",slug:"/paraflow/bindings",permalink:"/paranet/paraflow/bindings",draft:!1,unlisted:!1,editUrl:"https://github.com/your-org/your-project/edit/main/paranet/paraflow/bindings.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"bindings",title:"Bindings",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Tables",permalink:"/paranet/paraflow/tables"},next:{title:"Runtime Internals",permalink:"/paranet/paraflow/runtime_internals"}},d={},c=[{value:"Call Bindings",id:"call-bindings",level:2},{value:"Data Pattern Bindings",id:"data-pattern-bindings",level:2},{value:"Structuring/Destructuring Bindings",id:"structuringdestructuring-bindings",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"bindings",children:"Bindings"})}),"\n",(0,t.jsx)(n.h2,{id:"call-bindings",children:"Call Bindings"}),"\n",(0,t.jsx)(n.p,{children:'The following "call" constructs make use of call bindings to associate actuals to the callee\'s formals:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Goal creation and completion (assert/fail/cancel)"}),"\n",(0,t.jsx)(n.li,{children:"Event enablement"}),"\n",(0,t.jsx)(n.li,{children:"Paralogue function call"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Call bindings are written as a list of bindings like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<formal> \u201c->\u201d <actual>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where ",(0,t.jsx)(n.code,{children:"formal"})," is the goal/event/paralogue parameter name and ",(0,t.jsx)(n.code,{children:"actual"})," is any Paraflow expression."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"@resolveAccount(email -> $email, source -> $source);\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the actual is simply a local variable of the same name as the formal, then the binding may be written in shorthand without the formal name and arrow. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"!startOrder(id -> $order, $batch);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Is the shorthand equivalent of:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"!startOrder(id -> $order, batch -> $batch);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"data-pattern-bindings",children:"Data Pattern Bindings"}),"\n",(0,t.jsx)(n.p,{children:"Pattern bindings are used to match data tuples of various types. They consist of constraints used to select matching tuples together with input bindings that assign elements of matching tuples to local variables."}),"\n",(0,t.jsx)(n.p,{children:"There are many constructions that make use of pattern bindings:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Rule/task head constraints"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"with"}),", ",(0,t.jsx)(n.code,{children:"foreach"}),", ",(0,t.jsx)(n.code,{children:"forall"})," statements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exists"})," expression (restricted to only constraints)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Pattern bindings are written as a list of constraints/bindings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<bool-expression> | <name> \u201c:\u201d <variable>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where ",(0,t.jsx)(n.code,{children:"name"})," is a column (tables) or parameter name (goals), and boolean expressions reference at least one column/parameter name."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"with oweItem(id == $id, qty > 0, sku: $sku) \u2026\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the variable name is the same as the column/parameter name, then the binding may be written in shorthand without the field name and colon. For example, the statement above may have been written:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"with oweItem(id == $id, qty > 0, $sku) \u2026\n"})}),"\n",(0,t.jsx)(n.h2,{id:"structuringdestructuring-bindings",children:"Structuring/Destructuring Bindings"}),"\n",(0,t.jsx)(n.p,{children:"Structuring/destructuring bindings are used when working with object data received (or returned) from (to) external services. These are used in the following statements:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"let"})," with Paralogue function (destructuring)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"return"})," (structuring)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The left-hand side of a destructuring ",(0,t.jsx)(n.code,{children:"let"})," statement has the following form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u201c{\u201c <destructure-binding-list> \u201c}\u201d\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where a destructure binding is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<field> \u201c:\u201d <variable> [ \u201c(\u201c <column-list> \u201c)\u201d ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"The values of fields are assigned to the given local variables. If the field is an array of objects, then a local table variable is constructed with column names in the column list. The columns are extracted from the fields by the same name of the array elements."}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"let { account: $account } = @resolveAccount(email -> $email)\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the variable is the same as the field, then the binding may be written in shorthand without the field name and colon. For example, the statement above may have been written:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"let { $account } = @resolveAccount(email -> $email)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The right-hand side of the ",(0,t.jsx)(n.code,{children:"return"})," statement has the following form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u201c{\u201c <structure-binding-list> \u201c}\u201d\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where a structure binding is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<field> \u201c:\u201d <expression>\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"return { id: $order_id }\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the expression is simply a local variable with the same name as the field, then the binding may be written in shorthand without the field name and colon."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);